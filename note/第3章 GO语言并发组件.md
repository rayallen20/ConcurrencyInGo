# Concurrency In Go

## 第3章 GO语言并发组件

### goroutine

goroutine是GO语言程序中最基本的组织单位之一.**事实上每个GO语言程序都至少有1个goroutine:main goroutine**.它在进程开始时自动创建并启动.

简单来讲,goroutine是一个并发的函数(记住:不一定是并行的),与其他代码一起运行.

****

个人理解:

并发是代码的属性,描述的是一个代码块具备和其他代码块在同一时刻被运行的能力;

并行是对运行时状态的描述,描述的是有2段代码在同一时刻被运行;

有并发能力的代码不一定能够被并行运行.比如这些代码被运行在了只有1个CPU核心的机器上.

****

```go
package main

import "fmt"

func main() {
	go sayHello()
	// 继续执行自己的逻辑
}

func sayHello() {
	fmt.Println("Hello")
}
```

既然goroutine是一个并发的函数,那么它也可以基于一个匿名函数被创建:

```go
package main

import "fmt"

func main() {
	go func() {
		fmt.Println("Hello")
	}()
	// 继续执行自己的逻辑
}
```

第8行:必须立刻在`go`关键字后面调用匿名函数来使用

也可以将函数分配给一个变量,并将这个函数命名为一个匿名函数:

```go
package main

import "fmt"

func main() {
	sayHello := func() {
		fmt.Println("Hello")
	}

	go sayHello()
	// 继续执行自己的逻辑
}
```

**这意味着我们可以用一个函数和一个关键字来创建一个并发的逻辑块**.

goroutine是如何工作的?

GO语言中,goroutine是独一无二的.goroutine不是OS线程,也不是绿色线程(由语言运行时管理的线程),**它们是一个更高级别的抽象,称为协程**.**协程是一种非抢占式的简单并发子程序(函数、闭包或方法),也就是说,协程不能被中断.但是协程有多个点,允许暂停或重新进入**.

goroutine没有定义自己的暂停或再运行点.GO的运行时会观察goroutine的运行时行为,并在它们阻塞时自动挂起它们,然后在它们不被阻塞时恢复它们.这使得它们具备了抢占的能力,但只是在goroutine被阻塞的地方具备这种能力.GO的运行时和goroutine的逻辑是一种优雅的合作关系.因此,goroutine可以被认为是一种特殊类型的协程.

协程可以被认为是goroutine的隐式并发结构,但并发并不是协程自身的属性.**某样东西必须能够同时托管几个协程,并且给每个协程一个执行的机会,才能够并发**.当然,有可能的情况是:有几个协程正在按顺序执行,但给了人一种并行执行的假象.实际上在GO中,这样的情况比较常见.

**GO语言的主机托管机制是一个名为M:N调度器的实现.这意味着它将M个绿色线程映射到N个OS线程.然后将goroutine安排在绿色线程上**.






Go的宿主机制实现了所谓的M：N调度器，这意味着它将M个绿色线程映射到N个系统线程。 Goroutines随后被安排在绿色线程上。 当我们拥有比绿色线程更多的goroutine时，调度程序处理可用线程间goroutines的分布，并确保当这些goroutine被阻塞时，可以运行其他goroutines。我们将在第六章讨论所有这些机制是如何工作的，但在这里我们将介绍Go如何对并发进行建模。





















































