# Concurrency In Go

## 第4章 GO语言并发编程范式

### 队列排队

在之前的章节我们列举了pipeline的各种优点.但有时候,你需要在pipeline尚未就绪的前提下就开始接受请求,这一点是很有用的.这个过程被称为队列.

这也就意味着一旦pipeline中的某个阶段完成了一些工作,它就要把结果存储在内存中的某个临时区域,以便后续的其他阶段可以找到这个结果,且这个完成工作的阶段不需要保持对这个结果的引用.实际上我们之前在[第3章 GO语言并发组件 channel章节](https://github.com/rayallen20/ConcurrencyInGo/blob/master/note/%E7%AC%AC3%E7%AB%A0%20GO%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E7%BB%84%E4%BB%B6/3.%20channel.md#%E7%BC%93%E5%86%B2%E7%AE%A1%E9%81%93)中我们已经讨论了带有缓冲区的channel,其实它就是一种队列,只是之前我们没有真正的使用它,这是有原因的.

尽管将队列引入你的系统是非常有用的,但是它通常是优化系统的最后手段.过早地引入队列会导致同步问题(例如死锁和活锁)的隐藏.此外,随着程序朝着正确性收敛,你可能会发现你需要更多或更少的队列.

那么队列的好处在哪儿呢?让我们通过一个在系统调优时常见的错误来回答这个问题:引入队列试图解决性能问题.**队列几乎永远不能减少你程序的总运行时长,它只能让你程序的行为变得不同**.

让我们通过一个例子来理解这句话.

```go
done := make(chan interface{})
defer close(done)

zeros := take(done, 3, repeat(done, 0))
short := sleep(done, 1 * time.Second, zeros)
long := sleep(done, 4 * time.Second, short)
pipeline := long
```

这个pipeline共4个阶段:

1. `repeat()`阶段:生成一个包含无限个0的流的阶段
2. `take()`阶段:从`repeat()`阶段中取出3个0之后,取消`repeat()`阶段的阶段
3. `short`阶段:一个短耗时阶段,休眠1s
4. `long`阶段:一个长耗时阶段,休眠4s

此处我们假定`repeat()`阶段和`short()`阶段是瞬时完成的,我们只关注2个`sleep()`阶段是如何对pipeline的整体运行时间带来影响的.以下表格显示了时间`t`、迭代`i`(即pipeline中正在处理第几个0)以及`short`阶段和`long`阶段分别还剩下多少秒才会继续处理下一个值

|Time(t)|i|`long`阶段|`short`阶段|备注|
|:-:|:-:|:-:|:-:|:-:|
|0|0|尚未开始|尚未开始|pipeline尚未开始运行|
|1|0|4s|1s|初态:`long`阶段需休眠4s;`short`阶段需休眠1s|
|2|0|3s|blocked|此时`long`阶段还需再休眠3s才会从`short`阶段返回的只读channel中读取数据;`short`阶段由于没有人从自己返回的只读channel中读取数据而阻塞|
|3|0|2s|blocked|此时`long`阶段还需再休眠2s才会从`short`阶段返回的只读channel中读取数据;`short`阶段由于没有人从自己返回的只读channel中读取数据而阻塞|
|4|0|1s|blocked|此时`long`阶段还需再休眠1s才会从`short`阶段返回的只读channel中读取数据;`short`阶段由于没有人从自己返回的只读channel中读取数据而阻塞|
|5|1|4s|1s|此时`long`阶段已经完成了从`short`阶段返回的只读channel中读取数据的过程,整个pipeline完成了1次迭代;`long`阶段再次休眠4s;`short`阶段再次休眠1s|
|6|1|3s|blocked|此时`long`阶段还需再休眠3s才会从`short`阶段返回的只读channel中读取数据;`short`阶段由于没有人从自己返回的只读channel中读取数据而阻塞|
|7|1|2s|blocked|此时`long`阶段还需再休眠2s才会从`short`阶段返回的只读channel中读取数据;`short`阶段由于没有人从自己返回的只读channel中读取数据而阻塞|
|8|1|1s|blocked|此时`long`阶段还需再休眠1s才会从`short`阶段返回的只读channel中读取数据;`short`阶段由于没有人从自己返回的只读channel中读取数据而阻塞|
|9|2|4s|close|此时`long`阶段已经完成了从`short`阶段返回的只读channel中读取数据的过程,整个pipeline完成了2次迭代;`long`阶段再次休眠4s;`short`阶段已经完成了3次迭代,由于`zeros`阶段返回的只读channel关闭,导致`short`阶段返回的只读channel也关闭了,也就是说`short`阶段完成了工作|
|10|2|3s||此时`long`阶段还需再休眠3s才会从`short`阶段返回的只读channel中读取数据;`short`阶段已经结束了|
|11|2|2s||此时`long`阶段还需再休眠2s才会从`short`阶段返回的只读channel中读取数据;`short`阶段已经结束了|
|12|2|1s||此时`long`阶段还需再休眠1s才会从`short`阶段返回的只读channel中读取数据;`short`阶段已经结束了|
|13|3|close||`long`阶段也完成了3次迭代,由于`short`阶段返回的只读channel被关闭,导致`long`阶段返回的只读channel也随之关闭了,也就是说`long`阶段也完成了工作.即:整个pipeline完成了工作|

可以看到,整个pipeline耗时13s,`short`阶段运行了9s

如果我们在pipeline中加入缓冲区,会发生什么?我们在`short`阶段和`long`阶段之间引入一个长度为2的缓冲区:

```go
done := make(chan interface{})
defer close(done)

zeros := take(done, 3, repeat(done, 0))
short := sleep(done, 1 * time.Second, zeros)
buffer := buffer(done, 2, short)
long := sleep(done, 4 * time.Second, buffer)
pipeline := long
```

|Time(t)|i|`long`阶段|缓冲区占用情况|`short`阶段|备注|
|:-:|:-:|:-:|:-:|:-:|:-:|
|0|0|尚未开始|0/2|尚未开始|pipeline尚未开始运行|
|1|0|4s|0/2|1s|初态:`long`阶段需休眠4s;`short`阶段需休眠1s|
|2|0|3s|1/2|1s|此时`long`阶段还需再休眠3s;`short`阶段将结果暂存至缓冲区.对于`short`阶段而言,完成了第1次迭代,开始了第2次迭代|
|3|0|2s|2/2|1s|此时`long`阶段还需再休眠2s;`short`阶段将结果暂存至缓冲区,对于`short`阶段而言,完成了第2次迭代,开始了第3次迭代|

TODO:我认为再往下`short`阶段应该要阻塞了,因为前2次产生的结果都在缓冲区了,第3次迭代是无法开始的

















































