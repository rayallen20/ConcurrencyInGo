# Concurrency In Go

## 第4章 GO语言并发编程范式

### 队列排队

在之前的章节我们列举了pipeline的各种优点.但有时候,你需要在pipeline尚未就绪的前提下就开始接受请求,这一点是很有用的.这个过程被称为队列.

这也就意味着一旦pipeline中的某个阶段完成了一些工作,它就要把结果存储在内存中的某个临时区域,以便后续的其他阶段可以找到这个结果,且这个完成工作的阶段不需要保持对这个结果的引用.实际上我们之前在[第3章 GO语言并发组件 channel章节](https://github.com/rayallen20/ConcurrencyInGo/blob/master/note/%E7%AC%AC3%E7%AB%A0%20GO%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E7%BB%84%E4%BB%B6/3.%20channel.md#%E7%BC%93%E5%86%B2%E7%AE%A1%E9%81%93)中我们已经讨论了带有缓冲区的channel,其实它就是一种队列,只是之前我们没有真正的使用它,这是有原因的.

尽管将队列引入你的系统是非常有用的,但是它通常是优化系统的最后手段.过早地引入队列会导致同步问题(例如死锁和活锁)的隐藏.此外,随着程序朝着正确性收敛,你可能会发现你需要更多或更少的队列.

那么队列的好处在哪儿呢?让我们通过一个在调整系统性能时常见的错误来回答这个问题:引入队列试图解决性能问题.队列几乎永远不能减少你程序的总运行时长,它只能让你程序的行为变得不同.















