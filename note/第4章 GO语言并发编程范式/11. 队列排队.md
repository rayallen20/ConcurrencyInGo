# Concurrency In Go

## 第4章 GO语言并发编程范式

### 队列排队

在之前的章节我们列举了pipeline的各种优点.但有时候,你需要在pipeline尚未就绪的前提下就开始接受请求,这一点是很有用的.这个过程被称为队列.

这也就意味着一旦pipeline中的某个阶段完成了一些工作,它就要把结果存储在内存中的某个临时区域,以便后续的其他阶段可以找到这个结果,且这个完成工作的阶段不需要保持对这个结果的引用.实际上我们之前在[第3章 GO语言并发组件 channel章节](https://github.com/rayallen20/ConcurrencyInGo/blob/master/note/%E7%AC%AC3%E7%AB%A0%20GO%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E7%BB%84%E4%BB%B6/3.%20channel.md#%E7%BC%93%E5%86%B2%E7%AE%A1%E9%81%93)中我们已经讨论了带有缓冲区的channel,其实它就是一种队列,只是之前我们没有真正的使用它,这是有原因的.

尽管将队列引入你的系统是非常有用的,但是它通常是优化系统的最后手段.过早地引入队列会导致同步问题(例如死锁和活锁)的隐藏.此外,随着程序朝着正确性收敛,你可能会发现你需要更多或更少的队列.

那么队列的好处在哪儿呢?让我们通过一个在系统调优时常见的错误来回答这个问题:引入队列试图解决性能问题.**队列几乎永远不能减少你程序的总运行时长,它只能让你程序的行为变得不同**.

让我们通过一个例子来理解这句话.

```go
done := make(chan interface{})
defer close(done)

zeros := take(done, 3, repeat(done, 0))
short := sleep(done, 1 * time.Second, zeros)
long := sleep(done, 4 * time.Second, short)
pipeline := long
```

这个pipeline共4个阶段:

1. `repeat()`阶段:生成一个包含无限个0的流的阶段
2. `take()`阶段:从`repeat()`阶段中取出3个0之后,取消`repeat()`阶段的阶段
3. `short`阶段:一个短耗时阶段,休眠1s
4. `long`阶段:一个长耗时阶段,休眠4s

此处我们假定`repeat()`阶段和`short()`阶段是瞬时完成的,我们只关注2个`sleep()`阶段是如何对pipeline的整体运行时间带来影响的.以下表格显示了时间`t`、迭代`i`(即pipeline中正在处理第几个0)以及`short`阶段和`long`阶段分别还剩下多少秒才会继续处理下一个值

|Time(t)|i|`long`阶段|`short`阶段|备注|
|:-:|:-:|:-:|:-:|:-:|
|0|0|尚未开始|1s|初态:整个pipeline尚未开始运行.但`short`已经执行了1次(TODO:我不知道为什么这里初态时就执行了1次).|
|1|0|4s|1s|`long`阶段从`short`阶段中拿到了第1个0,可以开始运行了,即开始等待4s;`short`阶段在上一秒产生的运行结果被`long`取走,因此也可以继续开始第2次迭代|
|2|0|3s|(blocked)|`long`阶段还需等待3s;`short`阶段此时由于没有人来取第2次迭代的结果,因此被阻塞|
|3|0|2s|(blocked)|`long`阶段还需等待2s;`short`阶段此时由于没有人来取第2次迭代的结果,因此被阻塞|
|4|0|1s|(blocked)|`long`阶段还需等待1s;`short`阶段此时由于没有人来取第2次迭代的结果,因此被阻塞|
|5|1|4s|1s|`long`阶段完成了第1次迭代,这样就宣布整个pipeline完成了第1次迭代,同时在这1s内,`long`阶段再次从`short`阶段中取出了第2个0,开始了该阶段的第2次迭代,即再次等待4s;`short`阶段由于第2次迭代的结果被取走,因此取消阻塞,进入第3次迭代|
|6|1|3s|(blocked)|`long`阶段还需等待3s;`short`阶段此时由于没有人来取第3次(即最后一次)迭代的结果,因此被阻塞|
|7|1|2s|(blocked)|`long`阶段还需等待2s;`short`阶段此时由于没有人来取第3次(即最后一次)迭代的结果,因此被阻塞|
|8|1|1s|(blocked)|`long`阶段还需等待1s;`short`阶段此时由于没有人来取第3次(即最后一次)迭代的结果,因此被阻塞|
|9|2|4s|(closed)|`long`阶段完成了第2次迭代,这样就宣布整个pipeline完成了第2次迭代,同时在这1s内,`long`阶段再次从`short`阶段中取出了第3个0,开始了该阶段的第3次迭代,即再次等待4s;`short`阶段由于最后一次迭代的结果被取走,因此完成任务,关闭channel|
|10|2|3s|(closed)|`long`阶段还需等待3s;`short`阶段的返回值已关闭|
|11|2|2s|(closed)|`long`阶段还需等待2s;`short`阶段的返回值已关闭|
|12|2|1s|(closed)|`long`阶段还需等待1s;`short`阶段的返回值已关闭|
|13|3|(closed)|(closed)|`long`阶段也完成了自己最后一次迭代,因此关闭返回值channel,整个pipeline结束|


如果我们在pipeline中加入缓冲区,会发生什么?我们在`short`阶段和`long`阶段之间引入一个长度为2的缓冲区:

```go
done := make(chan interface{})
defer close(done)

zeros := take(done, 3, repeat(done, 0))
short := sleep(done, 1 * time.Second, zeros)
// 给short阶段增加一个缓冲区 长度为2
buffer := buffer(done, 2, short)
long := sleep(done, 4 * time.Second, buffer)
pipeline := long
```

|Time(t)|i|`long`阶段|缓冲区占用情况|`short`阶段|备注|
|:-:|:-:|:-:|:-:|:-:|:-:|
|0|0|尚未开始|0/2|1s|初态:整个pipeline尚未开始运行.但`short`已经执行了1次(TODO:我不知道为什么这里初态时就执行了1次).|
|1|0|4s|0/2|1s|`long`阶段从`short`阶段中直接拿到第1个0开始工作,即等待4s;`short`阶段开始第2次迭代|
|2|0|3s|1/2|1s|`long`阶段还需等待3s;`short`阶段将第2次迭代的结果存入缓冲区,开始第3次迭代|
|3|0|2s|2/2|(closed)|`long`阶段还需等待2s;`short`阶段第3次(即最后一次)迭代结束,将第3次迭代的结果存入缓冲区.`short`阶段完成任务,关闭返回的channel|
|4|0|1s|2/2|(closed)|`long`阶段还需等待1s|
|5|1|4s|1/2|(closed)|`long`阶段完成了第1次迭代,即整个pipeline完成了第1次迭代.`long`阶段从缓冲区内取出第2个0,开始第2次迭代,即:等待4s|
|6|1|3s|1/2|(closed)|`long`阶段还需等待3s|
|7|1|2s|1/2|(closed)|`long`阶段还需等待2s|
|8|1|1s|1/2|(closed)|`long`阶段还需等待1s|
|9|2|4s|0/2|(closed)|`long`阶段完成了第2次迭代,即整个pipeline完成了第2次迭代.`long`阶段从缓冲区内取出第3个0,开始第3次迭代,即:等待4s|
|10|2|3s|0/2|(closed)|`long`阶段还需等待3s|
|11|2|2s|0/2|(closed)|`long`阶段还需等待2s|
|12|2|1s|0/2|(closed)|`long`阶段还需等待1s|
|13|2|(closed)|0/2|(closed)|`long`阶段完成第3次(即最后一次)迭代,关闭返回的channel.这意味着整个pipeline完成了最后一次迭代|

可以看到,整个pipeline依然需要13s才能完成迭代,但其中的`short`阶段的耗时从之前的9s降低到了3s.也就是说我们通过加入缓冲区,使得`short`阶段的运行时间缩短了2/3.但是整个pipeline还是需要13s才能执行完毕,那么缩短`short`阶段的运行时间这件事,意义何在呢?










































